// DANGER! This code was autogenerated from template by github.com/vl4deee11/upool/codegen/.
// For more info check github.com/vl4deee11/upool/codegen/main.go
package main

import (
	"unsafe"
)

const maxInChunks = 10
const size = int(unsafe.Sizeof(new(int)))

type UPoolInt struct {
	New        func() int
	currChunk  int
	currOffset int
	freeptrs   []uintptr
	memChunks  [][maxInChunks * size]byte
}

func NewUPoolInt(new func() int, pSize int) *UPoolInt {
	return &UPoolInt{
		New:       new,
		memChunks: make([][maxInChunks * size]byte, 0, pSize),
		freeptrs:  make([]uintptr, 0, pSize),
	}
}

// noescape: unused now
func (p *UPoolInt) noescape(up unsafe.Pointer) unsafe.Pointer {
	return unsafe.Pointer(uintptr(up) ^ 0)
}

// uintptr2t: uintptr to type convert
func (p *UPoolInt) uintptr2t(ptr uintptr) *int {
	return (*int)(unsafe.Pointer(ptr))
}

// t2uintptr: type to uintptr convert
func (p *UPoolInt) t2uintptr(v *int) uintptr {
	return uintptr(unsafe.Pointer(v))
}

// malloc: allocate new memory chunk
func (p *UPoolInt) malloc() {
	p.memChunks = append(p.memChunks, [maxInChunks * size]byte{})
}

// Get struct from pool
func (p *UPoolInt) Get() *int {
	if len(p.freeptrs) != 0 {
		ptr := p.freeptrs[len(p.freeptrs)-1]
		p.freeptrs = p.freeptrs[:len(p.freeptrs)-1]
		return p.uintptr2t(ptr)
	}

	st := p.New()
	if len(p.memChunks) == 0 {
		p.malloc()
	}

	if p.currOffset == len(p.memChunks[p.currChunk]) {
		p.malloc()
		p.currOffset = 0
		p.currChunk++
	}

	ptr := unsafe.Pointer(&st)

	bs := *(*[size]byte)(ptr)
	for i := range bs {
		p.memChunks[p.currChunk][p.currOffset+i] = bs[i]
	}
	p.currOffset += size
	return (*int)(unsafe.Pointer(&p.memChunks[p.currChunk][p.currOffset-size]))
}


//Return struct to pool
func (p *UPoolInt) Return(st *int) {
	p.freeptrs = append(p.freeptrs, p.t2uintptr(st))
}
